<wrapper-page-algoviz>
  <h1 class="rounded-box green">Визуализация алгоритмов локальной балансировки BST-дерева</h1>
  <wrapper-content>
    <left-column>
      <div>
        <h2 class="rounded-box yellow">МЕТОДЫ</h2>
        <content-part>
          <div class="method-item active">BST_Balance(t)</div>
          <div class="method-item">
              <text-block>BST_Balance(t)</text-block>
              <marker-list></marker-list>
          </div>
          <div class="method-item">BST_Balance(t)</div>
          <div class="method-item">BST_Balance(t)</div>
          <div class="method-item">BST_Balance(t)</div>
        </content-part>
      </div>
      <div>
        <h2 class="rounded-box yellow">ОПИСАНИЕ</h2>
        <content-part>
          <p>У BST-деревьев два основных недостатка – значительный объем дополнительной памяти для связей в дереве и возможность
            вырождения дерева в список.</p>
          <p>Рассмотрим способы ба-лансировки дерева, снижающие эффект вырождения деревьев в худших
            случаях. Очень часто дерево формируют элементы упорядоченного файла, или файла с большим числом
            дублированных ключей. В этом случае построение дерева будет занимать квадратичное время, а поиск - линейное время</p>

        </content-part>
      </div>
    </left-column>
    <center-column>
      <div>
        <h2 class="rounded-box yellow">дерево двоичного поиска (bst)</h2>
        <content-part>
        </content-part>
      </div>
    </center-column>
    <right-column>
      <div>
        <h2 class="rounded-box yellow"><!-- МЕТОДЫ--></h2>
        <content-part>
        </content-part>
      </div>
      <div>
        <h2 class="rounded-box yellow">КОММЕНТАРИЙ К КОДУ</h2>
        <content-part>
          <p>Рекурсинонный вызов функции <red-text>BST_Balance(t)</red-text> с аргументом левое поддерева</p>
          <counter-part><p>Шаг №3 из 10</p></counter-part>
        </content-part>
      </div>
    </right-column>
  </wrapper-content>
</wrapper-page-algoviz>
